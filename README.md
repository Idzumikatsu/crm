# Schedule Tracker

Монорепозиторий включает backend на Spring Boot и SPA на React.

## Структура проекта

- `backend/` — серверная часть и REST API
- `frontend/` — клиентское приложение Vite/React
- `infra/` — Docker Compose и конфигурация NGINX
- `docs/` — документация и ADR

## Настройка окружения

1. **Java 21**
   - Установите JDK 21. На Linux можно установить пакет `openjdk-21-jdk`.
2. **Gradle**
   - Используйте Gradle 8.14 или запускайте через прилагаемый скрипт `./backend/gradlew`.
3. **PostgreSQL**
   - Приложение ожидает базу `schedule` с пользователем `postgres` и паролем `postgres`.
   - Быстрый вариант через Docker:
     ```bash
     docker run --name schedule-db -p 5432:5432 -e POSTGRES_DB=schedule \
      -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -d postgres:15.3
     ```
    - В `application.yml` адрес БД задаётся через переменную окружения `DB_HOST`.
      По умолчанию используется `localhost`. Если профиль `postgres` не активирован,
      используется встроенная база H2.
    - Для миграций используется Flyway **11.9.1**, что обеспечивает поддержку
      PostgreSQL 15.3.
4. **Сборка и запуск backend**
   - Сборка: `./backend/gradlew build`
   - Запуск: `./backend/gradlew bootRun`
   - Приложение слушает порт `8080`. Убедитесь, что этот порт свободен
     перед запуском, иначе старт завершится ошибкой.
   - При первом запуске Gradle скачает зависимости из Maven Central.
     Требуется подключение к интернету или локальный кеш артефактов.
   - В проект подключен модуль `spring-boot-starter-validation`,
     поэтому запросы валидируются через Bean Validation.
5. **Запуск тестов**
   - Выполните `./backend/gradlew test`.

6. **Сборка CSS**
   - Для обновления стилей Tailwind запустите `npm run build` из корня
     репозитория. Результат появится в `backend/src/main/resources/static`.

7. **Прокси**
   - Для получения зависимостей может потребоваться сетевой прокси.
     Укажите его хост и порт в переменных окружения
     `PROXY_HOST` и `PROXY_PORT` (а также `HTTP_PROXY` и `HTTPS_PROXY`
     вида `http://<host>:<port>`), чтобы Maven и Git могли
     подключаться к удалённым репозиториям. Если переменные не заданы,
     прокси не используется.
  - Для автоматического создания настроек воспользуйтесь скриптом
    `scripts/setup-proxy.sh`. Он создаёт `.mvn/settings.xml` только при
    наличии переменных окружения `PROXY_HOST` и `PROXY_PORT`, иначе
    генерирует пустой файл и прокси не используется. Скрипт также
    настраивает git при наличии `HTTP_PROXY`/`HTTPS_PROXY`.
   - Файл `.mvn/jvm.config` по умолчанию пуст, поэтому параметры
     прокси передаются только через переменные окружения.
   - Если проект собирается через GitHub Actions, эти значения
     необходимо задать как секреты репозитория `PROXY_HOST` и
     `PROXY_PORT`.

## Запуск в Docker

Приложение использует профиль `postgres`, поэтому его нужно активировать
через переменную `SPRING_PROFILES_ACTIVE`. Также контейнеру требуется адрес
сервиса PostgreSQL в переменной `DB_HOST`. Если вы создавали контейнер БД по
примеру выше, его имя `schedule-db`. Для связи контейнеров понадобится сеть
`app-network`; создайте её при необходимости командой `docker network create
app-network`. Запуск приложения выглядит так:

```bash
docker run --rm -it --network app-network \
  -e DB_HOST=schedule-db \
  -e SPRING_PROFILES_ACTIVE=postgres \
  --name my-java-app my-java-app
```

Для удобства можно воспользоваться `infra/docker-compose.dev.yml`, который
поднимет PostgreSQL, само приложение и Nginx в роли обратного прокси. Перед
запуском убедитесь, что в каталоге `backend/` есть `app.jar`:

```bash
./gradlew build
cp $(ls build/libs/*.jar | grep -v plain | head -n 1) app.jar
cd ..
docker compose -f infra/docker-compose.dev.yml up --build
```

### Проверка сервиса
После деплоя убедитесь, что контейнеры запущены:
```bash
docker compose ps -a
```
Если сервис `app` отсутствует или имеет статус `Exited`, убедитесь,
что перед сборкой был создан `app.jar`, и просмотрите лог:
```bash
docker compose logs app
```
Частая причина ошибки 502/503 — приложение не смогло подключиться к базе. Запустите контейнеры повторно:
```bash
docker compose -f infra/docker-compose.dev.yml up -d
```

После запуска метрики Nginx доступны на `http://localhost:9114/metrics`.
Экспортер считывает данные со страницы `/nginx_status` внутри контейнера.



## Учетные записи

После первого запуска создаются учетные записи менеджера и преподавателя.
Параметры входа:
- менеджер: `manager`/`manager`
- преподаватель: `teacher`/`teacher`

При активном профиле `test` эти пользователи не создаются, что упрощает
написание интеграционных тестов.

Новые пользователи могут зарегистрироваться через POST `/api/auth/register`,
передав `username`, `password` и опциональное `role` в теле запроса.

## Веб-интерфейс

SPA реализована на React и располагается в каталоге `frontend/`.
Для локальной разработки выполните в нём:

```bash
cd frontend
npm install
npm run dev
```

Приложение будет доступно на `http://localhost:5173` и использует REST API
бэкэнда на порту 8080.

Производственная сборка выполняется командой `npm run build`, после чего файлы
появятся в `frontend/dist`. Их можно раздавать через NGINX или другой web-сервер.

Для совместимости в каталоге `backend/src/main/resources/static` остаются
упрощённые HTML-страницы, доступные без авторизации.

### REST API
Основные эндпоинты:
- `POST /api/auth/login` и `POST /api/auth/register`
- CRUD для преподавателей `/api/teachers`
- CRUD для студентов `/api/students`
- CRUD для групп `/api/groups`
- Управление слотами преподавателей `/api/time-slots`
- Работа с занятиями `/api/lessons` (проверяется наличие слота преподавателя и отсутствие пересечений)
- Получение данных пользователя `/api/users`


## API документация

После запуска приложения документация Swagger доступна по адресу
`/swagger-ui.html`. Там перечислены все доступные REST эндпоинты.

## CI/CD

Репозиторий содержит workflow `.github/workflows/deploy.yml`, который автоматически деплоит приложение на выделенный VPS при пуше в ветку `main`. Для корректной работы необходимо создать следующие секреты репозитория:

- `VPS_HOST` – адрес сервера;
- `VPS_USER` – имя пользователя для подключения;
- `VPS_PASSWORD` – пароль пользователя;
- `VPS_PORT` – SSH‑порт, если отличается от `22`;
- `PROXY_HOST` и `PROXY_PORT` – при необходимости использовать сетевой прокси.

Workflow собирает JAR, копирует его и файлы инфраструктуры на сервер и запускает `docker compose -f infra/docker-compose.dev.yml up -d`.
Сервер должен иметь установленный Docker версии **27.5.1** или новее (API 1.47), так как деплой тестировался на этой версии.
После успешного завершения всех проверок Pull Request в `main` автоматически сливается через auto-merge.




